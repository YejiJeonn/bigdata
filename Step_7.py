# -*- coding: utf-8 -*-
"""기말 프로젝트_7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XR_rZlF8ppAMGl1fLZ6i6jojG2MZ-4jj
"""

!apt-get update
!apt-get install -y fonts-nanum
!fc-cache -fv

# 1. 금, 비트코인 기반 주식(KOSPI) 수익률 예측
# 단순 선형회귀(Linear Regression) 기반 예측

import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from sklearn.linear_model import LinearRegression

# 학습 기간 (Train)
train_start = "2009-01-01"
train_end   = "2015-12-31"

# 테스트 기간 (Test)
test_start = "2016-01-01"
test_end   = "2019-01-01"

tickers = {
    "Gold": "GLD",
    "Bitcoin": "BTC-USD",
    "KOSPI": "^KS11"
}

# YFinance 데이터 다운로드
train_data = {}
test_data = {}

for name, ticker in tickers.items():
    train_data[name] = yf.download(ticker, start=train_start, end=train_end)['Close']
    test_data[name]  = yf.download(ticker, start=test_start, end=test_end)['Close']

# 데이터 병합 (데이터값 열로 들어가도록 concat)
train_df = pd.concat(train_data.values(), axis=1)
train_df.columns = train_data.keys()
print("[학습데이터]")
print("금 총 데이터수 / 결측치 수: ", len(train_df['Gold']), train_df['Gold'].isna().sum())
print("코인 총 데이터수 / 결측치 수: ", len(train_df['Bitcoin']), train_df['Bitcoin'].isna().sum())
print("주식(KOSPI) 총 데이터수 / 결측치 수: ", len(train_df['KOSPI']), train_df['KOSPI'].isna().sum())
train_df = train_df.dropna()
print("최종 학습 데이터 개수: ", len(train_df))

print()

test_df = pd.concat(test_data.values(), axis=1)
test_df.columns = test_data.keys()
print("[테스트 데이터]")
print("금 총 데이터수 / 결측치 수: ", len(test_df['Gold']), test_df['Gold'].isna().sum())
print("코인 총 데이터수 / 결측치 수: ", len(test_df['Bitcoin']), test_df['Bitcoin'].isna().sum())
print("주식(KOSPI) 총 데이터수 / 결측치 수: ", len(test_df['KOSPI']), test_df['KOSPI'].isna().sum())
test_df = test_df.dropna()
print("최종 학습 데이터 개수: ", len(test_df))

# 변동률 계산 (수익률)
train_ret = train_df.pct_change().dropna()
test_ret  = test_df.pct_change().dropna()

# 선형 회귀 학습 (2009~2018)
X_train = train_ret[['Gold', 'Bitcoin']]
y_train = train_ret['KOSPI']

model = LinearRegression().fit(X_train, y_train)

print()
print("학습 완료!")
print("회귀계수:", model.coef_)
print("절편:", model.intercept_)

# 테스트 (2019~2025 예측)
X_test = test_ret[['Gold', 'Bitcoin']]
y_test = test_ret['KOSPI']

pred = model.predict(X_test)

# 그래프 출력
plt.figure(figsize=(12, 6))
plt.plot(y_test.index, y_test, label='실제 KOSPI 수익률', alpha=0.7)
plt.plot(y_test.index, pred, label='예측 KOSPI 수익률', alpha=0.7)
plt.title("금·비트코인 기반 KOSPI 수익률 예측 (학습: 2009~2018 / 테스트: 2019~2025)")
plt.xlabel("날짜")
plt.ylabel("KOSPI 수익률")
plt.legend()
plt.grid(True)
plt.show()

# ARIMA, LSTM 공통 코드
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf

start = "2009-01-01"
end   = "2025-01-01"

gld   = yf.download("GLD",      start=start, end=end)
btc   = yf.download("BTC-USD",  start=start, end=end)
kospi = yf.download("^KS11",    start=start, end=end)

df = pd.concat(
    [gld['Close'], btc['Close'], kospi['Close']],
    axis=1,
    keys=['Gold', 'Bitcoin', 'KOSPI']
).dropna()

# 수익률(로그 수익률 추천)
df_ret = np.log(df).diff().dropna()

# 2. ARIMA
from statsmodels.tsa.arima.model import ARIMA

# KOSPI 로그 수익률만 사용
kospi_ret = df_ret['KOSPI']

# 학습/테스트 분리 (마지막 20%를 테스트)
split = int(len(kospi_ret) * 0.8)
train_ret = kospi_ret.iloc[:split]
test_ret  = kospi_ret.iloc[split:]

# ARIMA(p,d,q) = (1,0,1) 예시 (수익률은 이미 차분된 것으로 간주)
model = ARIMA(train_ret, order=(1,0,1))
result = model.fit()

print(result.summary())

# 테스트 구간 예측
forecast_ret = result.forecast(steps=len(test_ret))
# 수익률 → 지수로 복원
last_price = df['KOSPI'].iloc[split - 1]
pred_prices = [last_price]

for r in forecast_ret:
    pred_prices.append(pred_prices[-1] * np.exp(r))

pred_series = pd.Series(pred_prices[1:], index=test_ret.index)

# 그래프
plt.figure(figsize=(12,5))
plt.plot(df['KOSPI'].iloc[split:], label='실제 KOSPI')
plt.plot(pred_series, label='ARIMA 예측 KOSPI', linestyle='--')
plt.title("ARIMA 기반 KOSPI 예측")
plt.xlabel("날짜")
plt.ylabel("KOSPI 지수")
plt.legend()
plt.grid(True)
plt.show()

# 3. ARIMAX (Gold/BTC를 외생변수로 넣기)

from statsmodels.tsa.arima.model import ARIMA

# 타겟: KOSPI 수익률
y = df_ret['KOSPI']
# 외생변수: Gold, Bitcoin 수익률
X = df_ret[['Gold', 'Bitcoin']]

split = int(len(y) * 0.8)

y_train, y_test = y.iloc[:split], y.iloc[split:]
X_train, X_test = X.iloc[:split], X.iloc[split:]

# ARIMAX: order=(1,0,1) + exog
model_ex = ARIMA(y_train, order=(1,0,1), exog=X_train)
result_ex = model_ex.fit()
print(result_ex.summary())

# 테스트 구간 예측
forecast_ret_ex = result_ex.forecast(steps=len(y_test), exog=X_test)

# 수익률 → 지수로 복원
last_price = df['KOSPI'].iloc[split - 1]
pred_prices_ex = [last_price]
for r in forecast_ret_ex:
    pred_prices_ex.append(pred_prices_ex[-1] * np.exp(r))

pred_series_ex = pd.Series(pred_prices_ex[1:], index=y_test.index)

plt.figure(figsize=(12,5))
plt.plot(df['KOSPI'].iloc[split:], label='실제 KOSPI')
plt.plot(pred_series_ex, label='ARIMAX 예측 KOSPI (Gold/BTC 포함)', linestyle='--')
plt.title("ARIMAX(Gold, Bitcoin 포함) 기반 KOSPI 예측")
plt.xlabel("날짜")
plt.ylabel("KOSPI 지수")
plt.legend()
plt.grid(True)
plt.show()

# 4. LSTM

# 전처리
from sklearn.preprocessing import MinMaxScaler
import numpy as np

# LSTM에는 보통 가격 그대로 스케일링해서 씀
data = df.copy()

scaler = MinMaxScaler()
scaled = scaler.fit_transform(data)  # 순서: [Gold, Bitcoin, KOSPI]

scaled_df = pd.DataFrame(scaled, index=data.index, columns=data.columns)

# 시퀀스 만들기
def create_sequences(dataset, target_col_idx, window=60):
    X, y = [], []
    for i in range(window, len(dataset)):
        X.append(dataset[i-window:i, :])            # window일치 전체 feature
        y.append(dataset[i, target_col_idx])        # 그 다음날 KOSPI 값
    return np.array(X), np.array(y)

window = 60
# target_idx = list(scaled_df.columns).index("KOSPI")
target_idx = scaled_df.columns.get_loc("KOSPI")


X_all, y_all = create_sequences(scaled_df.values, target_idx, window=window)

# 학습/테스트 분리 (80/20)
split = int(len(X_all) * 0.8)
X_train, X_test = X_all[:split], X_all[split:]
y_train, y_test = y_all[:split], y_all[split:]

###

# LSTM 모델 정의 및 학습

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

model = Sequential()
model.add(LSTM(64, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(Dropout(0.2))
model.add(LSTM(32, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(1))  # 다음날 KOSPI 스케일 값

model.compile(optimizer='adam', loss='mse')

history = model.fit(
    X_train, y_train,
    epochs=20,
    batch_size=32,
    validation_split=0.1,
    verbose=1
)

###

# 예측
y_pred = model.predict(X_test).reshape(-1)
y_true = y_test.reshape(-1)

n = len(y_pred)
n_features = scaled_df.shape[1]

# target_idx 반드시 정수로 보장!!
target_idx = scaled_df.columns.get_loc("KOSPI")
print("target_idx:", target_idx, type(target_idx))

# ---- 예측값 dummy 구성 ----
dummy_pred = np.zeros((n, n_features))

# 기존 방식은 slice 문제가 생김 → 반복문으로 안전하게 처리
for i in range(n):
    dummy_pred[i, target_idx] = y_pred[i]

inv_pred_all = scaler.inverse_transform(dummy_pred)
inv_pred = inv_pred_all[:, target_idx]

# ---- 실제값 dummy 구성 ----
dummy_true = np.zeros((n, n_features))
for i in range(n):
    dummy_true[i, target_idx] = y_true[i]

inv_true_all = scaler.inverse_transform(dummy_true)
inv_true = inv_true_all[:, target_idx]

# ---- 인덱스 맞추기 ----
test_index = scaled_df.index[window + split:]

plt.figure(figsize=(12,5))
plt.plot(test_index, inv_true, label="실제 KOSPI")
plt.plot(test_index, inv_pred, label="LSTM 예측 KOSPI", linestyle='--')
plt.title("LSTM 기반 KOSPI 예측 (입력: Gold, Bitcoin, KOSPI 과거 60일)")
plt.xlabel("날짜")
plt.ylabel("KOSPI 지수")
plt.legend()
plt.grid(True)
plt.show()